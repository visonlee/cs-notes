## 信息存储

### 十六进制表示法

|        |        |        |         |       |        |        |        |        | 
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 十六进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| 十进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| 二进制 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
|        |        |        |         |       |        |        |        |        | 
| 十六进制 | 8 | 9 | A | B | C | D | E | F |
| 十进制 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
| 二进制 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |


### 数据大小

| 有符号C声明 | 无符号C声明 | 32位字节数 | 64位字节数 | 
| :----: | :----: | :----: | :----: |
| [signed] char | unsigned char | 1 | 1 |
| short | unsigned short | 2 | 2 |
| int | unsigned | 4 | 4 |
| long | unsigned long | 4 | 8 |
| int32_t | uint32_t | 4 | 4 |
| int64_t | uint64_t | 8 | 8 |
| char * | | 4 | 8 |
| float | | 4 | 4 |
| double | | 8 | 8 |

### 字节序

假设变量 x的类型位int, 位于地址0x100处, 它的十六进制值为 0x01234567.那么地址范围0x100 ~ 0x103的字节顺序依赖机器的类型:

- 大端法:

| ... | 0x100 | 0x101 | 0x102 | 0x103 | ...|
| :----: | :----: | :----: | :----: | :----: |:----: |
| ... | 01 | 23 | 45 | 67 | ...|

- 小端法:

| ... | 0x100 | 0x101 | 0x102 | 0x103 | ...|
| :----: | :----: | :----: | :----: | :----: |:----: |
| ... | 67 | 45 | 23 | 01 | ...|

> 注: 我的机器是Intel机器, 使用小端模式。

<br>

## 布尔代数

- 逻辑运算(略)

- 位运算(略)

- 移位运算

1. 左移运算, x << k, x向左移动k位,丢弃最高的k位,并在右端补k个0
2. 右移运算分两种情况 `逻辑右移` 和 `算术右移`。对于`逻辑右移`, 与左移运算相反操作。对于`算术右移`,在左端补k个最高有效位的值.

下面来看一个例子,下表给出了对一个8位的参数x的两个不同的值做不同的移位操作得到的结果:

| 操作 | 值 | 值 |
| :----: | :----: | :----: |
| 参数x | [01100011] | [10010101] |
| x << 4 | [00110000] | [01010000] |
| x >> 4  (逻辑右移) | [00000110] | [00001001] |
| x >> 4  (算术右移) | [00000110] | [11111001] |

可以看到除了一个条目(表右下角)之外,其他的都包含填充0,即唯一例外的那个是算术右移[10010101]的情况,因为最高位是1,所以填充的也是1。

> C语言标准并没有明确定于对于`有符号数`应该使用哪种类型的右移(算术或者逻辑右移)。不幸地,这就意味着任何假设一种或者另外一种右移形式都会可能遇到可移植性的问题。然而, 实际上, 几乎所有的编译器/机器组合都对有符号数使用算术右移,而且许多程序员也假设机器会使用这种右移。另外, 对于无符号数,右移必须是逻辑右移的。

> 与C相比, Java对于右移有明确定义。 `x >> k` 是算术右移,  `x >>> k`是逻辑右移。

---
<br>

## 整数表示

### 无符号数编码
$B2U_w$ => (binary to unsign, length 4)

$B2U_4$([0001]) = 0 . 2^3 + 0 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 0 + 0 + 1 = 1

$B2U_4$([0101]) = 0 . 2^3 + 1 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 4 + 0 + 1 = 5

$B2U_4$([1011]) = 1 . 2^3 + 0 . 2^2 + 1 . 2^1 + 1 . 2^0 = 8 + 0 + 2 + 1 = 11

$B2U_4$([1111]) = 1 . 2^3 + 1 . 2^2 + 1 . 2^1 + 1 . 2^0 = 8 + 4 + 2 + 1 = 15

### 有符号数编码
对于负数编码, 使用`补码(Two’s-Complement)`,在这个定义中, 最高位被定义为`符号位`,`0`表示非负数, `1`表示负数。

$B2T_w$ (binary to two’s complement ,length w)

$B2T_4$([0001]) = −0 . 2^3 + 0 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 0 + 0 + 1 = 1

$B2T_4$([0101]) = −0 . 2^3 + 1 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 4 + 0 + 1 = 5

$B2T_4$([1011]) = −1 . 2^3 + 0 . 2^2 + 1 . 2^1 + 1 . 2^0 = −8 + 0 + 2 + 1 = −5

$B2T_4$([1111]) = −1 . 2^3 + 1 . 2^2 + 1 . 2^1 + 1 . 2^0 = −8 + 4 + 2 + 1 = −1


TODO: 原码、反码、补码

### 有符号数编码与无符号数编码之间的转换

考虑以下代码:
```C
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```
对于一台采用补码的机器上, 上述代码会产生如下输出:
```
v = -12345, nv = 53191
```
> 可以看到, 强制类型换砖的结果保持位值不变,只是改变了解释这些位的方式。即 `-12345`的16位补码与 `53191`的16位无符号表示是一样的。

类似地, 考虑以下代码:
```C
unsigned u = 4294967295u; /* UMax */
int tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
//u = 4294967295, tu = -1
//即无符号的4294967295U与补码形式的-1的位模式是一样的
```

### C语言中的有符号数和无符号数
C语言中有符号数使用`补码`形式。同时当一种类型赋值给另一种类型会发生隐式转换。如:

```C
int tx, ty;
unsigned ux,uy;
tx = ux; /* 相当于 tx = (int)ux; */
uy = ty; /* 相当于 uy = (unsigned)ty; */
```

当使用`printf`输出数值时, 分别使用指示符 `%d`(有符号十进制)、`%u`(无符号十进制) 和 `%x`(十六进制)格式输出。考虑以下代码:

```C
int x = -1;
unsigned u = 2147483648; /* 2的31次方 */

printf("x = %u = %d\n", x, x); 
printf("u = %u = %d\n", u, u);
```

在一个32位机器运行的输出如下:
```
x = 4294967295 = -1
u = 2147483648 = -2147483648
```
<br>

当执行一个运算时, 它的一个运算符是有符号的而另一个是无符号的, **那么C语言会隐式地将有符号参数强制类型转换为无符号数**, 并假设这两个数都是非负的,来执行这个运算. 这种方法对于标准的算术运算来说并无多大差异, 但是对于想 > 和 < 这样的关系运算来说, 它会导致非直观的结果。下表展示了以下关系表达式的示例已经他们得到的求值结果。这里假设数据类型int表示为32位补码。考虑 `-1 < 0U`.因为第二个运算时无符号的,第一个运算就会被隐式转换成无符号数, 因此表达式就等价于 `4294967295 < 0U`,这个答案明显时错误的。其他示例也可以通过类似的分析来理解。

| 表达式 | 类型 | 求值 |
| :----: | :----: | :----: |
| 0 == 0U | 无符号 | 1 |
| -1 < 0 | 有符号 | 1 |
| -1 < 0U | 无符号 | 0 `*` |
| 2147483647 > -2147483647-1 | 有符号 | 1 |
| 2147483647U > -2147483647-1 | 无符号 | 0 `*` |
| 2147483647 > (int) 2147483648U | 有符号 | 1 `*` |
| -1 > -2 | 有符号 | 1 |
| (unsigned) -1 > -2 | 无符号 | 1 |

> 注:非直观的情况标注了`*`

### 拓展一个数字的位表示

- 无符号数的零拓展(zero extension)
要将一个无符号数转换为更大的数据类型, 我们只要简单第在开头添加`0`。

- 补码数的符号拓展(sign extension)
要将一个有符号数转换为更大的数据类型, 我们只要简单第在开头添加最高位有效位的值。

```C
#include <stdio.h>
typedef unsigned char *byte_pointer;
void show_bytes(byte_pointer start, size_t len)
{
    int i;
    for (i = 0; i < len; i++)
        printf(" %.2x", start[i]);
    printf("\n");
}

void show_int(int x)
{
    show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void *x)
{
    show_bytes((byte_pointer)&x, sizeof(void *));
}
```

```C
    short sx = -12345; /* -12345 */
    unsigned short usx = sx; /* 53191 */
    int x = sx; /* -12345 有符号拓展 */ 
    unsigned ux = usx; /* 53191 零拓展 */

    printf("sx = %d:\t", sx);
    show_bytes((byte_pointer) &sx, sizeof(short));
    printf("usx = %u:\t", usx);
    show_bytes((byte_pointer) &usx, sizeof(unsigned short));
    printf("x = %d:\t", x);
    show_bytes((byte_pointer) &x, sizeof(int));
    printf("ux = %u:\t", ux);
    show_bytes((byte_pointer) &ux, sizeof(unsigned));
```

在采用补码的64位小端法机器运行这段代码时, 打印输出如下:
```
sx = -12345:     c7 cf
usx = 53191:     c7 cf
x = -12345:      c7 cf ff ff
ux = 53191:      c7 cf 00 00
```

### 截断数字

如下代码:
```C
int x = 53191;
short sx = (short)x; /* -12345, 截断,高16位丢弃 */
int y = sx; /* -12345, 符号拓展, 把高16位设置为1 */   
```

### 关于有符号数和无符号数的建议

就像我们看到的那样, 有符号数到无符号数的隐式强制类型转换导致某些非直观行为。这些非直观性的行为经常导致程序错误,并且这种错误很难被发现。

例子:

- 练习题2.25
```C
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length)
{
    int i;
    float result = 0;
    for (i = 0; i <= length - 1; i++)
        result += a[i];
    return result;
}
```
当参数length等于0时, 这段代码应该返回0.0。但实际上,运行该代码会发生一个内存错误,请解释为什么并修正。




- 练习题2.26
写一个函数用来断定一个字符串是否比另外一个更长。前提你时要用字符串的库函数strlen.它的声明如下:

```C
/* Prototype for library function strlen */
size_t strlen(const char *s);
```

最开始你写的函数是这样的 ：
```C
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
    return strlen(s) - strlen(t) > 0;
}
```
请说明这个函数会有什么问题, 并改正。






















