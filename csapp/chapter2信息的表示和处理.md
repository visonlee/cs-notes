## 信息存储

### 十六进制表示法

|        |        |        |         |       |        |        |        |        | 
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 十六进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| 十进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| 二进制 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
|        |        |        |         |       |        |        |        |        | 
| 十六进制 | 8 | 9 | A | B | C | D | E | F |
| 十进制 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
| 二进制 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |


### 数据大小

| 有符号C声明 | 无符号C声明 | 32位字节数 | 64位字节数 | 
| :----: | :----: | :----: | :----: |
| [signed] char | unsigned char | 1 | 1 |
| short | unsigned short | 2 | 2 |
| int | unsigned | 4 | 4 |
| long | unsigned long | 4 | 8 |
| int32_t | uint32_t | 4 | 4 |
| int64_t | uint64_t | 8 | 8 |
| char * | | 4 | 8 |
| float | | 4 | 4 |
| double | | 8 | 8 |

### 字节序

假设变量 x的类型位int, 位于地址0x100处, 它的十六进制值为 0x01234567.那么地址范围0x100 ~ 0x103的字节顺序依赖机器的类型:

- 大端法:

| ... | 0x100 | 0x101 | 0x102 | 0x103 | ...|
| :----: | :----: | :----: | :----: | :----: |:----: |
| ... | 01 | 23 | 45 | 67 | ...|

- 小端法:

| ... | 0x100 | 0x101 | 0x102 | 0x103 | ...|
| :----: | :----: | :----: | :----: | :----: |:----: |
| ... | 67 | 45 | 23 | 01 | ...|

> 注: 我的机器是Intel机器, 使用小端模式。

<br>

## 布尔代数

- 逻辑运算(略)

- 位运算(略)

- 移位运算

1. 左移运算, x << k, x向左移动k位,丢弃最高的k位,并在右端补k个0
2. 右移运算分两种情况 `逻辑右移` 和 `算术右移`。对于`逻辑右移`, 与左移运算相反操作。对于`算术右移`,在左端补k个最高有效位的值.

下面来看一个例子,下表给出了对一个8位的参数x的两个不同的值做不同的移位操作得到的结果:

| 操作 | 值 | 值 |
| :----: | :----: | :----: |
| 参数x | [01100011] | [10010101] |
| x << 4 | [00110000] | [01010000] |
| x >> 4  (逻辑右移) | [00000110] | [00001001] |
| x >> 4  (算术右移) | [00000110] | [11111001] |

可以看到除了一个条目(表右下角)之外,其他的都包含填充0,即唯一例外的那个是算术右移[10010101]的情况,因为最高位是1,所以填充的也是1。

> C语言标准并没有明确定于对于`有符号数`应该使用哪种类型的右移(算术或者逻辑右移)。不幸地,这就意味着任何假设一种或者另外一种右移形式都会可能遇到可移植性的问题。然而, 实际上, 几乎所有的编译器/机器组合都对有符号数使用算术右移,而且许多程序员也假设机器会使用这种右移。另外, 对于无符号数,右移必须是逻辑右移的。

> 与C相比, Java对于右移有明确定义。 `x >> k` 是算术右移,  `x >>> k`是逻辑右移。

---
<br>

## 整数表示

### 无符号数编码
$B2U_w$ => (binary to unsign, length 4)

$B2U_4$([0001]) = 0 . 2^3 + 0 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 0 + 0 + 1 = 1

$B2U_4$([0101]) = 0 . 2^3 + 1 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 4 + 0 + 1 = 5

$B2U_4$([1011]) = 1 . 2^3 + 0 . 2^2 + 1 . 2^1 + 1 . 2^0 = 8 + 0 + 2 + 1 = 11

$B2U_4$([1111]) = 1 . 2^3 + 1 . 2^2 + 1 . 2^1 + 1 . 2^0 = 8 + 4 + 2 + 1 = 15

### 有符号数编码
对于负数编码, 使用`补码(Two’s-Complement)`,在这个定义中, 最高位被定义为`符号位`,`0`表示非负数, `1`表示负数。

$B2T_w$ (binary to two’s complement ,length w)

$B2T_4$([0001]) = −0 . 2^3 + 0 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 0 + 0 + 1 = 1

$B2T_4$([0101]) = −0 . 2^3 + 1 . 2^2 + 0 . 2^1 + 1 . 2^0 = 0 + 4 + 0 + 1 = 5

$B2T_4$([1011]) = −1 . 2^3 + 0 . 2^2 + 1 . 2^1 + 1 . 2^0 = −8 + 0 + 2 + 1 = −5

$B2T_4$([1111]) = −1 . 2^3 + 1 . 2^2 + 1 . 2^1 + 1 . 2^0 = −8 + 4 + 2 + 1 = −1


### 原码、反码、补码

- `原码` 最高位表示符号位, 其他位表示数值, 最高位`0`表示正数, `1`表示负数
如下表:

| | 正数 |  | |  负数 |
| :----: | :----: | :----: | :----: | :----: |
| 0 | 0000 |  | -0 |  1000 |
| 1 | 0001 |  | -1 |  1001 |
| 2 | 0010 |  | -2 |  1010 |
| 3 | 0011 |  | -3 |  1011 |
| 4 | 0100 |  | -4 |  1100 |
| 5 | 0101 |  | -5 |  1101 |
| 6 | 0110 |  | -6 |  1110 |
| 7 | 0111 |  | -7 |  1111 |

原码的表示法很简单，虽然出现了+0和-0，但是直观易懂。于是开始运算——

0001+0010=0011，1+2=3；
0000+1000=1000，+0+(-0)=-0；
0001+1001=1010，1+(-1)=-2。
于是可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

原码的特点：

1. 原码表示直观、易懂，与真值转换容易。

2. 原码中0有两种不同的表示形式，给使用带来了不便,也浪费了一个数的使用空间。

通常0的原码用+0表示，若在计算过程中出现了-0，则需要用硬件将-0变成+0。
3. 原码表示加减运算复杂。

利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。

<br>

- `反码` 正数的反码还是等于原码; 负数的反码就是它的原码除符号位外，按位取反

原码最大的问题就在于一个数加上它的相反数不等于0，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

以带符号位的四位二进制数为例：3是正数，反码与原码相同，则可以表示为0011；-3的原码是1011，符号位保持不变，低三位按位取反，所以-3的反码为1100。

| | 正数 |  | 负数原码 |  | 负数反码 |
| :----: | :----: | :----: | :----: | :----: |  :----: |
| 0 | 0000 | -0 |  1000 | -0 | 1111 |
| 1 | 0001 | -1 |  1001 | -1 | 1110 |
| 2 | 0010 | -2 |  1010 | -2 | 1101 |
| 3 | 0011 | -3 |  1011 | -3 | 1100 |
| 4 | 0100 | -4 |  1100 | -4 | 1011 |
| 5 | 0101 | -5 |  1101 | -5 | 1010 |
| 6 | 0110 | -6 |  1110 | -6 | 1001 |
| 7 | 0111 | -7 |  1111 | -7 | 1000 |

再试着用反码的方式解决一下原码的问题——

0001+1110=1111，1+(-1)=-0;

1110+1100=1010，(-1)+(-3)=-5。(`计算结果错误`)

互为相反数相加等于0，虽然的到的结果是1111也就是-0。但是两个负数相加的出错了。

反码的特点：

1. 反码表示中, 最高位为符号位, 最高位`0`表示正数, `1`表示负数
2. 反码表示中，数值0有两种表示方法。
3. 反码的表示范围与原码的表示范围相同。

反码表示在计算机中往往作为数码变换的中间环节。

<br>

- `补码` 非负数的补码等于它的原码；负数的补码等于反码+1 

其实负数的补码等于反码+1只是补码的求法，而不是补码的定义，很多人以为求补码就要先求反码，其实并不是，那些计算机学家并不会心血来潮的把反码+1就定义为补码，只不过补码正好就等于反码+1而已。

如果有兴趣了解补码的严格说法，建议可以看一下《计算机组成原理》，它会用“模”和“同余”的概念，严谨地解释补码。

补码的特点：

1. 在补码表示中，用符号位表示数值的正负，形式与原码的表示相同，即0为非负，1为负。但补码的符号可以看做是数值的一部分参加运算。

非负数的补码表示就是其本身，负数的补码表示的实质是把负数映像到正值区域，因此加上一个负数或减去一个正数可以用加上另一个数（负数或减数对应的补码）来代替。
从补码表示的符号看，补码中符号位的值代表了数的正确符号，0表示非负数，1表示负数；而从映像值来看，符号位的值是映像值的一个数位，因此在补码运算中，符号位可以与数值位一起参加运算。
2. 在补码表示中，数值0只有一种表示方法。

3. 负数补码的表示范围比负数原码的表示范围略宽。纯小数的补码可以表示到-1，纯整数的补码可以表示到-2^n。

由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程z, 也简化了硬件电路的设计，因此`计算机中均采用补码进行加减运算`。

参考链接: [原码、反码、补码](https://zhuanlan.zhihu.com/p/99082236)

---

<br>

### 有符号数编码与无符号数编码之间的转换

考虑以下代码:
```C
short int v = -12345;
unsigned short uv = (unsigned short)v;
printf("v = %d, uv = %u\n", v, uv);
```
对于一台采用补码的机器上, 上述代码会产生如下输出:
```
v = -12345, nv = 53191
```
> 可以看到, 强制类型换砖的结果保持位值不变,只是改变了解释这些位的方式。即 `-12345`的16位补码与 `53191`的16位无符号表示是一样的。

类似地, 考虑以下代码:
```C
unsigned u = 4294967295u; /* UMax */
int tu = (int) u;
printf("u = %u, tu = %d\n", u, tu);
//u = 4294967295, tu = -1
//即无符号的4294967295U与补码形式的-1的位模式是一样的
```

### C语言中的有符号数和无符号数
C语言中有符号数使用`补码`形式。同时当一种类型赋值给另一种类型会发生隐式转换。如:

```C
int tx, ty;
unsigned ux,uy;
tx = ux; /* 相当于 tx = (int)ux; */
uy = ty; /* 相当于 uy = (unsigned)ty; */
```

当使用`printf`输出数值时, 分别使用指示符 `%d`(有符号十进制)、`%u`(无符号十进制) 和 `%x`(十六进制)格式输出。考虑以下代码:

```C
int x = -1;
unsigned u = 2147483648; /* 2的31次方 */

printf("x = %u = %d\n", x, x); 
printf("u = %u = %d\n", u, u);
```

在一个32位机器运行的输出如下:
```
x = 4294967295 = -1
u = 2147483648 = -2147483648
```
<br>

当执行一个运算时, 它的一个运算符是有符号的而另一个是无符号的, **那么C语言会隐式地将有符号参数强制类型转换为无符号数**, 并假设这两个数都是非负的,来执行这个运算. 这种方法对于标准的算术运算来说并无多大差异, 但是对于想 > 和 < 这样的关系运算来说, 它会导致非直观的结果。下表展示了以下关系表达式的示例已经他们得到的求值结果。这里假设数据类型int表示为32位补码。考虑 `-1 < 0U`.因为第二个运算时无符号的,第一个运算就会被隐式转换成无符号数, 因此表达式就等价于 `4294967295 < 0U`,这个答案明显时错误的。其他示例也可以通过类似的分析来理解。

| 表达式 | 类型 | 求值 |
| :----: | :----: | :----: |
| 0 == 0U | 无符号 | 1 |
| -1 < 0 | 有符号 | 1 |
| -1 < 0U | 无符号 | 0 `*` |
| 2147483647 > -2147483647-1 | 有符号 | 1 |
| 2147483647U > -2147483647-1 | 无符号 | 0 `*` |
| 2147483647 > (int) 2147483648U | 有符号 | 1 `*` |
| -1 > -2 | 有符号 | 1 |
| (unsigned) -1 > -2 | 无符号 | 1 |

> 注:非直观的情况标注了`*`

### 拓展一个数字的位表示

- 无符号数的零拓展(zero extension)
要将一个无符号数转换为更大的数据类型, 我们只要简单第在开头添加`0`。

- 补码数的符号拓展(sign extension)
要将一个有符号数转换为更大的数据类型, 我们只要简单第在开头添加最高位有效位的值。

```C
#include <stdio.h>
typedef unsigned char *byte_pointer;
void show_bytes(byte_pointer start, size_t len)
{
    int i;
    for (i = 0; i < len; i++)
        printf(" %.2x", start[i]);
    printf("\n");
}

void show_int(int x)
{
    show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x)
{
    show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void *x)
{
    show_bytes((byte_pointer)&x, sizeof(void *));
}
```

```C
    short sx = -12345; /* -12345 */
    unsigned short usx = sx; /* 53191 */
    int x = sx; /* -12345 有符号拓展 */ 
    unsigned ux = usx; /* 53191 零拓展 */

    printf("sx = %d:\t", sx);
    show_bytes((byte_pointer) &sx, sizeof(short));
    printf("usx = %u:\t", usx);
    show_bytes((byte_pointer) &usx, sizeof(unsigned short));
    printf("x = %d:\t", x);
    show_bytes((byte_pointer) &x, sizeof(int));
    printf("ux = %u:\t", ux);
    show_bytes((byte_pointer) &ux, sizeof(unsigned));
```

在采用补码的64位小端法机器运行这段代码时, 打印输出如下:
```
sx = -12345:     c7 cf
usx = 53191:     c7 cf
x = -12345:      c7 cf ff ff
ux = 53191:      c7 cf 00 00
```

### 截断数字

如下代码:
```C
int x = 53191;
short sx = (short)x; /* -12345, 截断,高16位丢弃 */
int y = sx; /* -12345, 符号拓展, 把高16位设置为1 */   
```

### 关于有符号数和无符号数的建议

就像我们看到的那样, 有符号数到无符号数的隐式强制类型转换导致某些非直观行为。这些非直观性的行为经常导致程序错误,并且这种错误很难被发现。

例子:

- 练习题2.25
```C
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length)
{
    int i;
    float result = 0;
    for (i = 0; i <= length - 1; i++)
        result += a[i];
    return result;
}
```
当参数length等于0时, 这段代码应该返回0.0。但实际上,运行该代码会发生一个内存错误,请解释为什么并修正。





- 练习题2.26
写一个函数用来断定一个字符串是否比另外一个更长。前提你时要用字符串的库函数strlen.它的声明如下:

```C
/* Prototype for library function strlen */
size_t strlen(const char *s);
```

最开始你写的函数是这样的:
```C
/* Determine whether string s is longer than string t */
/* WARNING: This function is buggy */
int strlonger(char *s, char *t) {
    return strlen(s) - strlen(t) > 0;
}
```
请说明这个函数会有什么问题, 并改正。






















