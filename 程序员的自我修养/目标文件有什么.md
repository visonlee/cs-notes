# 目标文件ELF详解

## elf 文件header

用下面C代码作例子来解释
```C
// gcc -c demo.c -o demo.o
unsigned long long var1 = 0xdddddddd11111111;
unsigned long long var2 = 0xcccccccc22222222;

int add(unsigned long long a, unsigned long long b)
{
    return a + b;
}
```

查看文件类型:
```
➜  file demo.o
demo.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
```

然后用不同的方式取查看`demo.o`这个目标文件里面有什么, 如下图(相同的内容用相同的数字标出):

![variable_args](./static/elf64_header.png)

这里用三种方式去了解elf文件的内容，总结如下:
- 1:  unsigned char	e_ident[EI_NIDENT];	其中EI_NIDENT为16,前4字节固定为 7f454c46的魔数,第5字节说明是ELF32或ELF64,第6字节是大端还是小端模式,第7字节固定为EI_VERSION,第8字节说名的是UNIX System V ABI,第9字节说明是ABI Version,最后7个字节为填充字节
- 2: elf文件类型,ET_REL是可重定位文件, ET_EXEC是可执行文件,还有其它类型请参考elf.h
- 3: 机器架构: 这里为x86-64 architecture
- 4: version, 固定为EV_CURRENT
- 5: 虚拟入口地址,因为本文件是目标可重定位文件, 所以为0
- 6: program header(ph)的开始的偏移位置, 目标文件没有program header.可执行elf才有,后面讲
- 7: section header(sh)的开始的偏移位置
- 8: e_flags, Processor specific flags for the ELF header e_flags field
- 9: elf header的大小为 sizeof(Elf64_Ehdr) = Elf64_Ehdr.e_ehsize = 64 bytes (红色)
- 10: 每一项program header(ph)的大小,因为目标文件没有ph,所以这里为0
- 11: program header项目的条数
- 12: 每一项section header(sh)的大小
- 13: section header项目的条数
- 14: Section header string table index

从上面的分析可以看出, 目前可以总结出elf的布局如下: 

![elf_obj_layout](./static/elf_obj_layout.png)

其中我们可以计算出`demo.o`目标文件的大小: 
`demo.o 大小 = e_ehsize + (e_shentsize * e_shnum ) = 688 + (64 * 12) = 1456 bytes`

使用 `ls -l demo.o`查看, 文件大小也是1456字节。 由此可见,section headers是一个类似数组的结构,并且在elf文件的最末尾。

另外, 留意到第一个section header项的二进制位全是0, 由此猜想第一个section header并不实际使用, 是一个虚空的section header.

---
<br>

## section header

上面我们了解了, ELF 目标文件的整体布局, 接下来我们再详细了解section header的详细内容。


我们可以使用以下命令来查看`section header`的内容, 具体如下:
```
➜  objdump -h demo.o

demo.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000001e  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  0000000000000000  0000000000000000  00000060  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000070  2**0
                  ALLOC
  3 .comment      0000002c  0000000000000000  0000000000000000  00000070  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000009c  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000a0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000c0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
➜  readelf -S demo.o
There are 12 section headers, starting at offset 0x2b0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       000000000000001e  0000000000000000  AX       0     0     1
  [ 2] .data             PROGBITS         0000000000000000  00000060
       0000000000000010  0000000000000000  WA       0     0     8
  [ 3] .bss              NOBITS           0000000000000000  00000070
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .comment          PROGBITS         0000000000000000  00000070
       000000000000002c  0000000000000001  MS       0     0     1
  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  0000009c
       0000000000000000  0000000000000000           0     0     1
  [ 6] .note.gnu.propert NOTE             0000000000000000  000000a0
       0000000000000020  0000000000000000   A       0     0     8
  [ 7] .eh_frame         PROGBITS         0000000000000000  000000c0
       0000000000000038  0000000000000000   A       0     0     8
  [ 8] .rela.eh_frame    RELA             0000000000000000  00000230
       0000000000000018  0000000000000018   I       9     7     8
  [ 9] .symtab           SYMTAB           0000000000000000  000000f8
       0000000000000120  0000000000000018          10     9     8
  [10] .strtab           STRTAB           0000000000000000  00000218
       0000000000000016  0000000000000000           0     0     1
  [11] .shstrtab         STRTAB           0000000000000000  00000248
       0000000000000067  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
```

`objdump -h` 和 `readelf -S` 都可以读取section header的信息, 但是`objdump`只是显示关键的 section, 而用`readelf`来查看则更信息。

每一项的`section header`的结构表示如下:
```C
// /usr/include/elf.h
typedef  uint32_t Elf64_Word;
typedef  uint64_t Elf64_Xword;
typedef  uint64_t Elf64_Addr;
typedef  uint64_t Elf64_Off;  

typedef struct
{
  Elf64_Word	sh_name;		/* Section name (string tbl index) */ // 
  Elf64_Word	sh_type;		/* Section type */                   
  Elf64_Xword	sh_flags;		/* Section flags */
  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */
  Elf64_Off	    sh_offset;		/* Section file offset */
  Elf64_Xword	sh_size;		/* Section size in bytes */
  Elf64_Word	sh_link;		/* Link to another section */
  Elf64_Word	sh_info;		/* Additional section information */
  Elf64_Xword	sh_addralign;   /* Section alignment */
  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */
} Elf64_Shdr;
```

即每一项的`section header`大小为 64 bytes (`sizeof(Elf64_Shdr)`).

下面来逐项拆解 `Elf64_Shdr`结构体.

| 属性 | 说明 |
| :----: | :----: |
| sh_name | Section name段名,段名是个字符串,它位于一个叫做“.shstrtab”的字符串表。sh_name是段名字符串在“.shstrtab”中的偏移 |
| sh_type | Section type段的类型详见后文 "段的类型" |
| sh_flags | Section flag段的标志位详见后文 "段的标志位" |
| sh_addr | Section Address段虚拟地址, 如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间中的虚拟地址;否则sh _addr为0 |
| sh_offset | Section Offset段偏移. 如果该段存在于文件中，则表示该段在文件中的偏移;否则无意义，比如sh_offset对于BSS段来说就没有意义 |
| sh_size | Section Size段的长度 | 
| sh_link | Section Link 和 Section Information 段链接信息,详见后文“段的链接信息”  |
| sh_info | Section Link 和 Section Information 段链接信息,详见后文“段的链接信息”  |
| sh_addralign | Section Address Alignment段地址对齐。有些段对段地址对齐有要求，比如我们假设有个段刚开始的位置包含了一个double变量,因为Intel x86系统要求浮点数的存储地址必须是本身的整数倍,也就是说保存double变量的地址必须是8字节的整数倍。这样对一个段来说，它的sh_addr 必须是8的整数倍。由于地址对齐的数量都是2的指数倍，sh_addralign表示是地址对齐数量中的指数，即sh_addrlign = 3表示对齐为2的3次方倍，即8倍，依此类推。所以一个段的地址sh _addr必须满足下面的条件，即sh _addr% (2*申sh_addralign)= 0。**表示指数运算。如果sh_addralign为0或1，则表示该段没有对齐要求 |
| sh_entsize | Section Entry Size项的长度。有些段包含了一些固定大小的项，比如符号表，它包含的每个符号所占的大小都是一样的。对于这种段，sh_entsize表示每个项的大小。如果为0，则表示该段不包含固定大小的项。 |


- 段的类型(sh_type)
```C
// /usr/include/elf.h
/* Legal values for sh_type (section type).  */
#define SHT_NULL	  0		/* Section header table entry unused */
#define SHT_PROGBITS	  1		/* Program data */
#define SHT_SYMTAB	  2		/* Symbol table */
#define SHT_STRTAB	  3		/* String table */
#define SHT_RELA	  4		/* Relocation entries with addends */
#define SHT_HASH	  5		/* Symbol hash table */
#define SHT_DYNAMIC	  6		/* Dynamic linking information */
#define SHT_NOTE	  7		/* Notes */
#define SHT_NOBITS	  8		/* Program space with no data (bss) */
#define SHT_REL		  9		/* Relocation entries, no addends */
#define SHT_SHLIB	  10		/* Reserved */
#define SHT_DYNSYM	  11		/* Dynamic linker symbol table */
#define SHT_INIT_ARRAY	  14		/* Array of constructors */
#define SHT_FINI_ARRAY	  15		/* Array of destructors */
#define SHT_PREINIT_ARRAY 16		/* Array of pre-constructors */
#define SHT_GROUP	  17		/* Section group */
#define SHT_SYMTAB_SHNDX  18		/* Extended section indeces */
#define	SHT_NUM		  19		/* Number of defined types.  */
#define SHT_LOOS	  0x60000000	/* Start OS-specific.  */
#define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes.  */
#define SHT_GNU_HASH	  0x6ffffff6	/* GNU-style hash table.  */
#define SHT_GNU_LIBLIST	  0x6ffffff7	/* Prelink library list */
#define SHT_CHECKSUM	  0x6ffffff8	/* Checksum for DSO content.  */
#define SHT_LOSUNW	  0x6ffffffa	/* Sun-specific low bound.  */
#define SHT_SUNW_move	  0x6ffffffa
#define SHT_SUNW_COMDAT   0x6ffffffb
#define SHT_SUNW_syminfo  0x6ffffffc
#define SHT_GNU_verdef	  0x6ffffffd	/* Version definition section.  */
#define SHT_GNU_verneed	  0x6ffffffe	/* Version needs section.  */
#define SHT_GNU_versym	  0x6fffffff	/* Version symbol table.  */
#define SHT_HISUNW	  0x6fffffff	/* Sun-specific high bound.  */
#define SHT_HIOS	  0x6fffffff	/* End OS-specific type */
#define SHT_LOPROC	  0x70000000	/* Start of processor-specific */
#define SHT_HIPROC	  0x7fffffff	/* End of processor-specific */
#define SHT_LOUSER	  0x80000000	/* Start of application-specific */
#define SHT_HIUSER	  0x8fffffff	/* End of application-specific */
```

- 段的标志位(sh_flags)
```C
// /usr/include/elf.h
/* Legal values for sh_flags (section flags).  */
#define SHF_WRITE	     (1 << 0)	/* Writable */
#define SHF_ALLOC	     (1 << 1)	/* Occupies memory during execution */
#define SHF_EXECINSTR	     (1 << 2)	/* Executable */
#define SHF_MERGE	     (1 << 4)	/* Might be merged */
#define SHF_STRINGS	     (1 << 5)	/* Contains nul-terminated strings */
#define SHF_INFO_LINK	     (1 << 6)	/* `sh_info' contains SHT index */
#define SHF_LINK_ORDER	     (1 << 7)	/* Preserve order after combining */
#define SHF_OS_NONCONFORMING (1 << 8)	/* Non-standard OS specific handling required */
#define SHF_GROUP	     (1 << 9)	/* Section is member of a group.  */
#define SHF_TLS		     (1 << 10)	/* Section hold thread-local data.  */
#define SHF_COMPRESSED	     (1 << 11)	/* Section with compressed data. */
#define SHF_MASKOS	     0x0ff00000	/* OS-specific.  */
#define SHF_MASKPROC	     0xf0000000	/* Processor-specific */
#define SHF_ORDERED	     (1 << 30)	/* Special ordering requirement (Solaris).  */
#define SHF_EXCLUDE	     (1U << 31)	/* Section is excluded unless referenced or allocated (Solaris).*/
```

对于系统保留的段,下表列举了他们的属性.
| name | sh_type | sh_flag|
| :----: | :----: | :----: |
| .bss | SHT_NOBITS | SHF_ALLOC+SHF_WRITE |
| .comment | SHT_PROGBITS | none |
| .data | SHT_PROGBITS | SHF_ALLOC + SHF_WRITE |
| .data1 | SHT_PROGBITS | SHF_ALLOC + SHF_WRITE |
| .debug | SHT_PROGBITS | none |
| .dynamic|  SHT_DYNAMIC | SHF_ALLOC + SHF_WRITE. 在有些系统.dynamic可能是只读的,所以没有SHF_WRITE标志位|
| .hash | SHT_HASH | SHF_ALLOC |
| .line | SHT_PROGBITS | none |
| .note | SHT_NOTE | none |
| .rodata | SHT_PROGBITS | SHF_ALLOC |
| .rodata1 | SHT_PROGBITS | SHF_ALLOC |
| .shstrtab | SHT_STRTAB | none |
| .strtab | SHT_STRTAB | 如果该ELF文件中有可装载的段须要用到该字符串表，那么该字符串表也将被装载到进程空间，则有SHF_ALLOC标志位 |
| .symtab | SHT_SYMTAB | 同字符串表.strtab|
| .text | SHT_PROGBITS | SHF_ALLOC + SHF_EXECINSTR |

- 段链接信息(sh_link、sh_info) 如果段的类型是与链接相关的(不论是动态链接或静态链接)，比如重定位表、符号表等，那么 sh_link 和 sh_info这两个成员所包含的意义如下表。对于其他类型的段，这两个成员没有意义。

| sh_type | sh_link | sh_info |
| :----: | :----: | :----: |
| SHT_DYNAMIC | 该段所使用的字符串表在段表中的下标 | 0 |
| SHT_HASH | 该段所使用的符号表在段表中的下标 | 0 |
| SHT_REL | 该段所使用的相应符号表在段表中的下标 | 该重定位表所作用的段,在段表中的下标 |
| SHT_RELA | 该段所使用的相应符号表在段表中的下标 | 该重定位表所作用的段,在段表中的下标 |
| SHT_SYMTAB | 操作系统相关的 | 操作系统相关的 |
| SHT_DYNSYM | 操作系统相关的 | 操作系统相关的 |
| other | SHN_UNDEF | 0 |

下面来使用一个例子来举例:TODO