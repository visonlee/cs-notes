## 信息存储

### 十六进制表示法

|        |        |        |         |       |        |        |        |        | 
| :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 十六进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| 十进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| 二进制 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
|        |        |        |         |       |        |        |        |        | 
| 十六进制 | 8 | 9 | A | B | C | D | E | F |
| 十进制 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
| 二进制 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |


### 数据大小

| 有符号C声明 | 无符号C声明 | 32位字节数 | 64位字节数 | 
| :----: | :----: | :----: | :----: |
| [signed] char | unsigned char | 1 | 1 |
| short | unsigned short | 2 | 2 |
| int | unsigned | 4 | 4 |
| long | unsigned long | 4 | 8 |
| int32_t | uint32_t | 4 | 4 |
| int64_t | uint64_t | 8 | 8 |
| char * | | 4 | 8 |
| float | | 4 | 4 |
| double | | 8 | 8 |

### 字节序

假设变量 x的类型位int, 位于地址0x100处, 它的十六进制值为 0x01234567.那么地址范围0x100 ~ 0x103的字节顺序依赖机器的类型:

- 大端法:

| ... | 0x100 | 0x101 | 0x102 | 0x103 | ...|
| :----: | :----: | :----: | :----: | :----: |:----: |
| ... | 01 | 23 | 45 | 67 | ...|

- 小端法:

| ... | 0x100 | 0x101 | 0x102 | 0x103 | ...|
| :----: | :----: | :----: | :----: | :----: |:----: |
| ... | 67 | 45 | 23 | 01 | ...|

> 注: 我的机器是Intel机器, 使用小端模式。

<br>

## 布尔代数

- 逻辑运算(略)

- 位运算(略)

- 移位运算

1. 左移运算, x << k, x向左移动k位,丢弃最高的k位,并在右端补k个0
2. 右移运算分两种情况 `逻辑右移` 和 `算术右移`。对于`逻辑右移`, 与左移运算相反操作。对于`算术右移`,在左端补k个最高有效位的值.

下面来看一个例子,下表给出了对一个8位的参数x的两个不同的值做不同的移位操作得到的结果:

| 操作 | 值 | 值 |
| :----: | :----: | :----: |
| 参数x | [01100011] | [10010101] |
| x << 4 | [00110000] | [01010000] |
| x >> 4  (逻辑右移) | [00000110] | [00001001] |
| x >> 4  (算术右移) | [00000110] | [11111001] |

可以看到除了一个条目(表右下角)之外,其他的都包含填充0,即唯一例外的那个是算术右移[10010101]的情况,因为最高位是1,所以填充的也是1。

> C语言标准并没有明确定于对于`有符号数`应该使用哪种类型的右移(算术或者逻辑右移)。不幸地,这就意味着任何假设一种或者另外一种右移形式都会可能遇到可移植性的问题。然而, 实际上, 几乎所有的编译器/机器组合都对有符号数使用算术右移,而且许多程序员也假设机器会使用这种右移。另外, 对于无符号数,右移必须是逻辑右移的。

> 与C相比, Java对于右移有明确定义。 `x >> k` 是算术右移,  `x >>> k`是逻辑右移。