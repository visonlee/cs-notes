# 静态链接

有如下c文件:
```C
/* a.c */
extern int shared;

void swap(int* a, int* b);

int main() {
    int a = 100;
    swap(&a, &shared);
    return 0;
}
```

```C
/* b.c */
int shared = 1;

void swap(int* a, int* b) {
    *a ^= *b ^= *a ^= *b;
}
```

使用`gcc -fno-stack-protector -c a.c b.c`编译生成`a.o`,`b.o`, 使用`ld a.o b.o -e main -o ab`链接生成`ab`(`ab`运行会发生`segmentation fault`,目前忽略它)

下面我们来看看链接过程做了什么:

## 空间地址与分配

```
➜ objdump -h a.o

a.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000002d  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  0000000000000000  0000000000000000  0000006d  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  0000006d  2**0
                  ALLOC
  3 .comment      0000002c  0000000000000000  0000000000000000  0000006d  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000099  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000a0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000c0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```

```
➜ objdump -h b.o

b.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         0000004f  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000004  0000000000000000  0000000000000000  00000090  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000094  2**0
                  ALLOC
  3 .comment      0000002c  0000000000000000  0000000000000000  00000094  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000c0  2**0
                  CONTENTS, READONLY
  5 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .eh_frame     00000038  0000000000000000  0000000000000000  000000e0  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```

```
➜ objdump -h ab

ab:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .note.gnu.property 00000020  00000000004001c8  00000000004001c8  000001c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000007c  0000000000401000  0000000000401000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .eh_frame     00000058  0000000000402000  0000000000402000  00002000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000004  0000000000404000  0000000000404000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000002b  0000000000000000  0000000000000000  00003004  2**0
                  CONTENTS, READONLY
```

- section 合并
从上面看出, ab的`.text`的大小(`0x7c`)等于 `a.o`的`.text`(`0x2d`)加上`b.o`的`.text`(`0x4f`),`.data`的情况也是。
说明在`ld`链接过程中把他们合并了。

使用如下命令`objdump -D -j .text ab`,确实是看到`swap`函数紧挨在`main`函数后面

- 分配虚拟地址

可以看到在.o的目标文件里面`VMA(virtual memory address)`都是0。而在可执行文件`AB`里面, 已经分配了VMA(`0x401000`).
使用`objdump -D -j .text ab`可以看到, `main`函数的虚拟地址也是为`0x401000`。
使用`gdb`验证，也是看到`main`函数的入口地址也是`0x401000`。(`starti`让程序停留在程序执行的第一条指令)
```
➜  gdb -q ./ab
Reading symbols from ./ab...
(No debugging symbols found in ./ab)
(gdb) starti
Starting program: /home/lws/os/linker_loader/chapter4/ab

Program stopped.
0x0000000000401000 in main ()
(gdb)
```
使用`readelf -h ab`,也可以看到`Entry point address:` 也是`0x401000`

## 符号解析与重定位

![relocation](./static/relocation.png)

在目标文件中, 因为还不知道`shared`和 `swap`目标地址在哪里, 所以统统用`0`填充。
而到了链接后的可执行文件`ab`中,就填上了目标地址。

- 上图在`1 -> 3`中
 `lea 0x2fe2(%rip),%rsi`, 是把`shared`的变量的地址传送给寄存器`rsi`,以用作传参数。
其中`0x2fe2(%rip)`稍微有点难理解,我们从elf文件布局入手来解释一下.

![elf_exec_view](./static/elf_exec_view.png)

elf执行文件的视图(图片来自维基百科), 其中从上到下为低地址到高地址.

我们执行的代码时放在`.text` section的, 而 `shared`是放在`.data` section的, 可以看到`.data`的地址比`.text`要高。

所以`0x2fe2(%rip)`表示当前程序正在执行的代码的地址(`rip`),再加上一个偏移值(`0x2fe2`), 就可以得到`shared`变量的地址了。即上面的 `数字3`那里, `&share = $rip + offest =  0x401017 + 0x2fe2`

- 上图在`2 -> 4`中

`e8`是`call`的机器码, `e8` 后面的是地址的偏移量, 所以数字4标注那里, 相当于是相对地址`call 0x07`,即相当于绝对地址`call 0x40102d = (0x401026 + 0x07)`


## 重定位表（TODO）